# TypeScript高频面试题及解析

- 这篇文章是关于 TypeScript 高频面试题及解析的整理。
- 涵盖: **类型系统**、**函数与类**、**泛型**、**模块化** 等众多方面。
  
基本概念：

- 接口 interface
- 枚举 enum
- 联合类型等
- 也有高级概念如协变逆变等
  
还介绍了各种特性：

- 可选参数
- 默认参数等
  
并通过代码示例进行说明，对理解 TypeScript 相关知识及应对面试有帮助。 

> 本文整理了一些TypeScript 的面试题，一起来看看吧！

面试题涉及了 TypeScript 语言的各个方面，包括 **基本语法**、**类型系统**、**函数**、**类**、**模块化**、**泛型**、**装饰器**等。在面试中，常见的 TypeScript 面试题主要围绕以下几个方面展开：

- **类型系统**：考察对 TypeScript 类型系统的理解，包括 **基本类型**、**联合类型**、**交叉类型**、**接口**、**类型别名**、**类型推断**、**类型守卫**等。
- **函数和类**：涉及 **函数** -> **参数类型**、**返回值类型**、**箭头函数**、**函数重载**、**类的定义**、**继承**、**访问修饰符** 等概念。
- **泛型**：考察在 **函数、类和接口** 中如何使用 **泛型** 来增加：代码的**灵活性**和**复用性**。
- **模块化**：问题可能涉及 ES6 模块化的语法、**导入导出方式** 以及 **模块解析** 等内容。
- **装饰器**：了解对 **装饰器的使用**，包括 **类装饰器**、**方法装饰器**、**属性装饰器** 以及 **参数装饰器** 的**定义和应用**。
- **编译配置**：熟悉 tsconfig.json 中的 **配置选项**，包括 **编译目标**、**模块系统**、**严格模式**等。
- **工程化实践**：了解 TypeScript 在项目中的**实际应用**，如与 **JavaScript 的混用**、**第三方库的声明文件使用**、**类型声明**等。

> 下面是上述涵盖内容的具体面试题～

## 什么是TypeScript

- TypeScript 是: 
  - 一种由微软开发的 **开源编程语言**，它是JavaScript的超集。
    - 超集: TypeScript包含了JavaScript的所有功能，并在此基础上添加了一些新的特性。
  - TypeScript通过添加:
    - **静态类型**
    - **类**
    - **接口**
    - **模块**
  - 等功能，使得在 **大型应用程序** 中更容易进行 **维护** 和 **扩展**。
  - 它可以被编译为纯 JavaScript，从而能够在任何支持JavaScript的地方运行。
  - 使用TypeScript可以 -> 帮助开发人员:
    - 编码过程中, 避免一些常见的错误。
    - 提供更好的 **代码编辑** 功能和 **工具支持**。

## 类型声明 和 类型推断 的区别，并 举例应用

- **类型声明**: **显式** 的为 变量 或 函数 **指定类型**。
- **类型推断**: TypeScript 根据 **赋值语句** 其 **右侧的值**，**自动推断** 变量的类型。例如：

```ts
// 类型声明
let x: number;
x = 10;
// 类型推断
let y = 20; // TypeScript会自动推断y的类型为number
```

- 类型声明的优点:
  - 可以 **明确** 变量的类型，提高代码的 **可读性**。
- 类型推断的优点:
  - 简化代码，减少 **重复** 的类型声明。
  - 使代码更加 **简洁**。

## 什么是接口（interface），它的作用，接口的使用场景。接口和类型别名（Type Alias）的区别

### 接口

- interface：
  - 用于 **描述** 对象的形状的 **结构化类型**。
  - 它定义了 -> 对象 -> 应该包含哪些: **属性**和 **方法**。
  - 在TypeScript中，接口可以用来:
    - **约束对象的结构**，以提高代码的 **可读性**和 **维护性**。例如：

```ts
interface Person {
    name: string;
    age: number;
}
function greet(person: Person) {
    return `Hello, ${person.name}!`;
}
```

- **接口** 的使用场景:
  - 在 **函数** 或 **类** 中: 用于 **约束参数** 或 **属性** 的类型。
  - 在 **对象** 的 **结构化描述** 中: 用于 **定义对象的形状**，也就是数据的 **结构**。

### 类型别名

- **类型别名**:
  - Type Alias
  - 用于给 **类型** 取一个 **别名**。
  - 可以用来定义 **基本类型**、**联合类型**、**交叉类型** 等。
  - 例如，定义一个 **字符串** 类型的别名：

```ts 
type Name = string;
let name: Name = 'Alice';
```

- **接口** 和 **类型别名** 的区别:
  - **接口**:
    - 只能用来 **描述对象的结构**。
    - 可以 **扩展** 和 **继承**。
  - **类型别名**:
    - 可以用来 **描述任意类型**。（基本类型、联合类型、交叉类型等）
    - 不能 **扩展** 和 **继承**。

## 什么是泛型（Generics），它的作用，泛型的使用场景

- **泛型**:
  - Generics
  - 是一种在定义 **函数、类或接口** 时，使用类型参数的方式。以增加代码的 **灵活性** 和 **重用性**。
  - 用于 **增强代码的灵活性** 和 **复用性**。
  - 可以在 **函数**、**类** 和 **接口** 中使用泛型。
  - 通过 **泛型**，可以 **延迟** 决定 **类型**，在使用时再指定具体的类型。
  - 例如，定义一个 **泛型函数**：

```ts
function identity<T>(arg: T): T {
      return arg;
}
let output = identity<string>('hello');
```

- **泛型** 的使用场景:
  - 在 **函数** 中: 用于 **约束参数** 和 **返回值** 的类型。
  - 在 **类** 中: 用于 **约束属性** 和 **方法** 的类型。
  - 在 **接口** 中: 用于 **描述对象** 的 **结构**。

## 枚举（enum）是什么，它的优势，应用案例。枚举和常量枚举的区别

### 枚举

- **枚举**:
  - Enum
  - 用于定义一组 **命名的常量**。
  - 枚举类型可以为一组数值赋予 **友好的名字**。
  - 例如，定义一个 **颜色枚举**：

```ts
enum Color {
      Red,
      Green,
      Blue
}
let c: Color = Color.Green;
```

- **枚举** 的优势:
  - 提高代码的 **可读性** 和 **可维护性**。
  - 避免使用 **魔法数**，使代码更加 **清晰**。
    - 魔法数: 代码中直接使用的数字，不容易理解。
  - 可以通过 **枚举值** 获取 **枚举名**，也可以通过 **枚举名** 获取 **枚举值**。
    - 例如，通过 **枚举值** 获取 **枚举名**：
      - `let colorName: string = Color[2]; // 输出: 'Blue'`
    - 通过 **枚举名** 获取 **枚举值**：
      - `let colorValue: number = Color['Green']; // 输出: 1`

### 常量枚举

- **常量枚举**:
  - Const Enums
  - 常量枚举是一种 **优化**，在编译阶段会被 **删除**。
  - 常量枚举会在使用的地方直接 **内联** 枚举值，而不会创建一个 **对象**。
  - 例如，定义一个 **常量枚举**：

```ts
const enum Direction {
      Up,
      Down,
      Left,
      Right
}

let directions = [Direction.Up, Direction.Down, Direction.Left, Direction.Right];
```

- **枚举** 和 **常量枚举** 的区别:
  - **枚举**:
    - 在 **运行时** 会生成一个 **对象**。
    - 可以通过 **枚举值** 获取 **枚举名**，也可以通过 **枚举名** 获取 **枚举值**。
  - **常量枚举**:
    - 在 **编译阶段** 会被 **删除**。
    - 会在使用的地方直接 **内联** 枚举值，而不会创建一个 **对象**。
      - 内联: 将 **枚举值** 直接替换到使用的地方。
      - 优点: 减少了 **运行时** 的开销。

## 如何处理 可空类型（nullable types）和 undefined类型，如何正确处理这些类型 以 避免潜在错误

### 可空类型

- **可空类型**:
  - Nullable Types
  - 在TypeScript中，可空类型是指：
    - 一个变量 -> 可以存储 -> 特定类型的 **值**，也可以存储 **null** 或 **undefined**。
    - 通过使用 **可空类型**，开发者可以:
      - 明确表达 -> 一个变量可能包含 **特定类型的值**，也可能 **不包含值（即为null或undefined）**。
    - 有助于提高代码的 **可读性**，并使得 **变量的可能取值范围** 更加 **清晰**。
    - 为了声明一个可空类型，可以使用联合类型（Union Types），例如 number | null 或 string | undefined。例如：

```ts
let numberOrNull: number | null = 10; 
numberOrNull = null; // 可以赋值为null 
    
let stringOrUndefined: string | undefined = "Hello"; 
stringOrUndefined = undefined; // 可以赋值为undefined
```

- **undefined类型**:
  - 在TypeScript中，可以通过 **联合类型** 或 **泛型** 来处理 **undefined类型**。
  - 例如，定义一个 **undefined类型** 的变量：

```ts
let y: number | undefined = undefined;
```

- **正确处理可空类型**:
  - 例如，使用 **类型断言** 处理 **可空类型**：

```ts
let z: number | null = null;
let result = z!.toFixed(); // 使用非空断言操作符'!'，避免空值错误
```

- **正确处理undefined类型**:
  - 例如，使用 **类型守卫** 处理 **undefined类型**：

```ts
let x: number | undefined = undefined;
if (x !== undefined) {
      let result = x.toFixed(); // 使用类型守卫，避免undefined错误
}
```

> 使用 **类型断言** 不能处理 **undefined类型**，因为 **undefined类型** 也是一种 **有效值**。因此，需要使用 **类型守卫** 来处理 **undefined类型**。


