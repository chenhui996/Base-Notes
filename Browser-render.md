# 浏览器渲染原理

- 浏览器渲染总体来说分为以下几步:
  - 浏览器通过 HTTP 或者 HTTPS 协议，先服务端请求页面;
  - 把请求回来的 HTML 解析成 DOM 树;
  - 把 CSS 解析成 CSSOM 树;
  - 把 DOM 树和 CSSOM 树组合在一起，生成渲染树(RENDER TREE);
  - 通过渲染树计算出布局(layout);
  - 渲染引擎会遍历 Render 树，绘制(painting)到界面上;
- 网络部分放到 TCP 协议中，在这就不多说了;

## 渲染流程

### 构建 DOM 树、CSSOM 树

- DOM 树和 CSSOM 树的构建流程非常像，就以 DOM 树为例:
  - 浏览器从服务器获取的是 16 进制文件流:比如 3C 62 6F 64 79 3E 48 65.....;
  - 浏览器要把'16 进制的 Bytes'转化成'字符串';
  - 再遍历这个'字符串'解析成'tokens';
- 浏览器是怎么将字符串解析成 tokens 的?
  - 使用的方法是状态机;

#### 状态机是怎么执行的？

- 接受到<字符。可能是一个标签的开头，开启一个状态:
  - 下一个字符是字母，就是标签名;
  - 下一个字符是！，就是注释;
  - ...
- 接受到非<字符。可能是一个文本节点，开启一个状态:

  - ...
    <br>

- 浏览器一步步将'文件流'转化为'字符串';
- 再通过状态机转化为 token;
- 得到 token 后:
  - 按照 W3C 规则转换成 DOM 树;

#### 简单总结

- 浏览器边接受文件流(进制编码内容)边编译为 token；
- 按照 w3c 规则进行字符解析:
  - 生成对应的 Tokens;
  - 最后转换为浏览器内核:
    - 可以识别渲染的 DOM 节点;
- 按照节点最后解析为对应的:
  - DOM TREE
  - CSSOM TREE

#### 需要注意的事：

- DOM 树构建过程可能会因为 css、js 而阻塞;
- DOM 树构建与 CSSOM 树构建可以同时进行;
- 不可见标签也会出现在 dom 树中;
- CSSOM 树构建过程可能会因为 js 而阻塞;

### 构建渲染树（Render Tree）

- 浏览器根据 DOM 树和 CSSOM 树：
  - 生成带有'标签'和'样式信息'的'渲染树'(Render Tree);
  - 渲染树与 DOM 树不是一一对应的关系;
    - 不显示的节点不会出现在渲染树上;

### 布局(Layout)

- 根据渲染树提供的'节点'和'样式';
  - 计算元素在视口中的确切的'大小'和'位置';

### 绘制(paining)

- 将元素计算后的'大小'和'位置'渲染到页面上'的过程';
- 渲染树的绘制工作是:
  - 浏览器调用 UI '后端组件'完成的;

### 回流和重绘（reflow 和 repaint）

- 一些操作会引发元素'位置'或者'大小'的'变化';
- 这样浏览器需要重新进行 Lauout 计算(回流/重排);
  - 重排完成后，浏览器需要重新绘制(重绘):
    - 第二次或多次布局(Lauout)就是回流/重排(reflow);
    - 第二次或多次绘制(paining)就是重绘(repaint);
- 如果是改变一些基础样式比如颜色:

  - 则不需要重排，只需要重绘即可:
  - 重绘：元素样式改变:
    - 例如：color、visibility...
  - 回流：元素大小、位置发生变化 - 例如：添加删除元素、视口大小改变...
    <br>

- 重绘不一定会回流，但是回流一定会触发重绘;

### 性能优化：减少 DOM 的回流

- 放弃传统操作 dom 的时代:
  - 基于 vue/react 开始'数据影响视图'模式(mvvm/mvc/virtual dom/dom diff....);
- 分离读写操作(现在的浏览器都有渲染队列的机制);
- 样式集中改变;
- 缓存布局信息;
- 元素批量修改;
- 使用 DocumentFragment 将需要多次修改的 DOM 元素缓存;
  - 最后一次性 append 到真实 DOM 中渲染;
- 变化多的元素脱离文档流:
  - 形成新的 Render Layer，降低回流成本;
- css3 硬件加速(GPU 加速)(会占用大量内存);

## 资源加载

- 浏览器自上而下读取代码，读取到资源文件

### css

- 使用 css 有三种方式：
  - 使用 link;
  - @import;
  - 内联样式;
- 其中 link 和@import 都是导入外部样式:
- 它们之间的区别：

  - link：
    - 浏览器会派发一个新的线程(HTTP 线程)去加载资源文件;
    - 与此同时 GUI 渲染线程会继续向下渲染代码;
  - @import：
    - GUI 渲染线程会暂时停止渲染;
    - 去服务器加载资源文件;
    - 资源文件没有返回之前不会继续渲染(阻碍浏览器渲染);
  - style：
    - GUI 直接渲染
      <br>

- 另外外部样式如果长时间没有加载完毕:
  - 浏览器为了用户体验:
    - 会使用浏览器会默认样式，确保首次渲染的速度;
- 所以 css 一般写在 head 中:
  - 让浏览器尽快发送请求去获取 css 样式;

### javascript

- JavaScript 执行线程与 GUI 渲染线程不能同时执行;
  - 这就意味着执行 js 代码势必会阻塞页面渲染;
- 为了不阻塞页面的渲染，可以：

  - script 标签放在页面的尾部，确保 dom 生成完再加载 js;
  - 尽可能使用 defer、async;
    <br>

- 关于<script>、<script defer>、<script async>的区别:
  - `<script>`:
    - 立即停止页面渲染去加载资源文件;
    - 当资源加载完毕后立即执行 js 代码;
    - js 代码执行完毕后继续渲染页面;
  - `<script defer>`:
    - 开辟新的线程去加载资源文件;
    - 当'资源加载完毕后'等待页面渲染;
    - 页面渲染完毕后再执行 js 代码;
  - `<script async>`:
    - 开辟新的线程去加载资源文件;
    - 当资源加载完毕后立即执行 js 代码;
    - js 代码执行完毕后继续渲染页面;
      - (特别注意：多个 async js 执行顺序是按照加载完毕的顺序，非 js 请求顺序);

### 补充：window.onload 和 DOMContentLoaded 的区别

- onload：
  - 是页面资源加载完毕，包括图片、视频资源;
- DOMContentLoaded：
  - DOM 渲染完成;

## 性能优化

- 了解这么多，最终还是要为了性能优化服务;
- 除了已经提过的减少回流的优化外，还有:
  - 减少 DOM 树渲染的时间:
    - HTML 层级不要太深;
    - 标签语义化(减少不标准语义化的特殊处理);
  - 减少 CSS 树渲染时间:
    - 减少层级嵌套(选择器是从右向左解析的);
    - (less、sass 嵌套是个大坑，注意);
  - 减少资源加载时间:
    - 利用浏览器并行加载资源次数、请求大小，不要太少也不要太多(6-7);
    - 一般会把 css 放在页面开始位置，提前请求:
      - 使用 link，不用@import;
      - 如果 css 少，尽可能采用内嵌式;
    - ssr 减少数据首页数据的请求;
    - 使用骨架屏、loding(感官上的提高，不会实际提高速度);
    - 避免阻塞的 js 加载:
      - js 放在页面底部;
      - 尽可能使用 defer、async;
