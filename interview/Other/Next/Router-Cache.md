# 路由缓存（Router Cache）

## 工作原理

- Next.js 有一个 **存放在内存中** 的 **客户端缓存**，它会在：
  - 用户会话期间，按 **路由段** 存储 RSC Payload。
  - 这就是路由缓存。
- 原理很好理解，例：
  1. 当访问 /a 的时候：因为是首次访问（MISS），将 /（layout）和 /a(page) 放在 **路由缓存** 中（SET）。(追加 / 和 /a)
  2. 当访问与 /a共享布局的 /b 的时候：使用路由缓存中的 /（layout），然后将 /b(page)放在路由缓存中（SET）。（追加 /b）
  3. 再次访问 /a的时候，直接使用路由缓存中（HIT）的 /(layout)和 /b(page)。
- 不止如此，当用户在 **路由之间导航**，Next.js 会 **缓存访问过的路由段** 并 **预获取** 用户可能导航的路由（基于视口内的 `<Link>` 组件）。
  - 这会为用户带来更好的 **导航体验**：
    1. 即时前进和后退导航，因为访问过的路由已经被缓存，并且 **预获取了新路由**。
    2. 导航不会导致页面重载，并且会 **保留 React 的状态** 和 **浏览器状态**。

## 持续时间

- **路由缓存** 存放在浏览器的临时缓存中，有两个因素决定了路由缓存的持续时间：
  - Session，缓存在导航时持续存在，当页面刷新的时候会被清除。
  - 自动失效期：单个路由段会在 **特定时长后** 自动失效。
    - 如果路由是 **静态渲染**，持续 5 分钟。
    - 如果路由是 **动态渲染**，持续 30s。
- 比如上面的 demo 中如果等 5 分钟后再去点击，就会重新获取新的 RSC Payload。

- 通过：
  - 添加 prefetch={true}（Link 组件的 prefetch 默认就为 true）。
  - 在 **动态渲染路由中** 调用 router.prefetch。
- 可以进入缓存 5 分钟。

## 失效方式

- 有两种方法可以让路由缓存失效：
  - **在 Server Action 中：**
    - 通过 revalidatePath 或 revalidateTag 重新验证数据。
    - 使用 cookies.set 或者 cookies.delete 会使路由缓存失效，这是为了防止使用 cookie 的路由过时（如身份验证）。
  - **调用 router.refresh：**
    - 会使 **路由缓存失效** 并发起一个 **重新获取当前路由** 的请求。

## 退出方式

- 无法退出路由缓存。
- 你可以通过给 `<Link>` 组件的 prefetch 传递 false 来退出预获取。
- 但依然会临时存储路由段 30s。
  - 这是为了实现：
    - **嵌套路由段** 之间的即时导航。此外访问过的路由也会被缓存。
