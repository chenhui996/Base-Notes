# 完整路由缓存（Full Route Cache）

## 工作原理

- Next.js 在构建的时候会 **自动渲染** 和 **缓存路由**。
- 这样当 **访问路由的时候**，可以直接使用 **缓存中的路由** 而不用 **从零开始在服务端渲染**，从而加快页面加载速度。

> 那你可能要问，缓存路由是个什么鬼？
> 我听过缓存数据，但是路由怎么缓存呢？
> 让我们复习下 Next.js 的渲染原理：

- Next.js 使用 React 的 API 来编排渲染。
- 当渲染的时候，渲染工作会根据 **路由** 和 **Suspense** 拆分成 **多个 chunk**。
  - **每个 chunk 分为两步进行渲染**：
  
### 1. RSC payload

- React 会将服务端组件渲染成一种特殊的数据格式，我们称之为 React Server Component Payload，简写为 RSC payload。
- 比如一个服务端组件的代码为：

```jsx
<div>
  Don’t give up and don’t give in.
  <ClientComponent />
</div>
```

- React 会将其转换为如下的 Payload：

```json
["$","div",null,{"children":["Don’t give up and don’t give in.", ["$","$L1",null,{}]]}]
1:I{"id":123,"chunks":["chunk/[hash].js"],"name":"ClientComponent","async":false}
```

- 这个格式针对流做了优化，它们可以以**流的形式**：
  - **逐行** 从服务端 **发送** 给客户端。
  - 客户端可以 **逐行解析** RSC Payload，**渐进式渲染页面**。

- 当然这个 RSC payload 代码肯定是不能直接执行的，它包含的更多是：
  - **信息**：
   1. 服务端组件的渲染结果
   2. 客户端组件的占位和引用文件
   3. 从服务端组件传给客户端组件的数据
- 比如这个 RSC Payload 中的 $L1 表示的就是 ClientComponent。
- 客户端会在收到 RSC Payload 后，解析下载 ClientComponent 对应的 bundle 地址，然后将执行的结果渲染到 $L1 占位的位置上。

### 2. 服务端渲染 HTML

- Next.js 会用 RSC payload 和客户端组件代码在服务端渲染 HTML。
- 简单来说，路由渲染的产物有两个：
  - 一个是 RSC Payload。
  - 一个是 HTML。
- 完整路由缓存，缓存的就是这两个产物。

- 不过路由在构建的时候，是否会被缓存，取决于它是 **静态渲染** 还是 **动态渲染**。
  - **静态路由** 默认都是会被缓存的。
  - **动态路由** 因为只能在请求的时候被渲染，所以不会被缓存。
- 例子：
  - 静态路由：`/about`。
  - 动态路由：`/post/[id]`
- 静态路由 `/about` 因为 **有完整路由缓存**，所以不会重新渲染一遍。
- 动态路由 /b 因为 **没有完整路由缓存**，所以会重新执行一遍渲染。
  - 但这并不影响客户端的路由缓存，所以在后续的请求中都命中了路由缓存。

## 持续时间

- **完整路由缓存** 默认是持久的，这意味着可以跨用户请求复用。

## 失效方式

- 有两种方式可以使完整路由缓存失效：
  - 重新验证数据：重新验证数据缓存会使完整路由缓存失效，毕竟渲染输出依赖于数据
  - 重新部署：数据缓存是可以跨部署的，但完整路由缓存会在重新部署中被清除

## 退出方式

- 退出 **完整路由缓存** 的方式就是将其 **改为动态渲染**：
  - **使用动态函数：**
    - 使用动态函数后会改为动态渲染，此时数据缓存依然可以用。
  - **使用路由段配置项：**
    - dynamic = 'force-dynamic'或 revalidate = 0 这会 **跳过完整路由缓存** 和 **数据缓存**。
    - 也就是说，每次请求时都会重新获取数据并渲染组件。
    - 此时 **路由缓存** 依然可以用，毕竟它是**客户端缓存**。
  - **退出数据缓存：**
    - 如果路由中有一个 fetch 请求退出了缓存，则会退出完整路由缓存。
    - 这个特定的 fetch 请求会在每次请求时重新获取，其他 fetch 请求依然会使用数据缓存。
    - Next.js 允许这种缓存和未缓存数据的混合。

> 简单来说，**完整路由缓存** 只适用于 **静态渲染**，在服务端保留静态渲染的产物 **RSC Payload 和 HTML**。
