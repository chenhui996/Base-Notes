# 其他

## 基础面试题

### 面试：JS 的严格模式

#### 1. 严格模式是什么？

**严格模式**（Strict Mode）是一种 **ECMAScript 5** 引入的新的 **JavaScript 执行模式**，它使得 JavaScript 在严格的条件下运行，从而提供更加安全和高效的开发环墍。

- **严格模式** 通过一些限制来消除一些不合理、不安全的语法，从而提高代码质量。
- **严格模式** 使得 JavaScript 引擎在执行代码时会进行更严格的解析和错误处理，从而减少一些不容易发现的错误。
- **严格模式** 还可以提高代码的运行速度，因为 JavaScript 引擎可以更好地优化代码。
- **严格模式** 是可选的，可以在整个脚本中启用，也可以在函数内部启用。
- **严格模式** 的使用方式是在脚本或函数的开头添加 `'use strict';`。

#### 严格模式具体有哪些限制？

**严格模式** 具有以下限制：

1. **禁止使用未声明的变量**：在严格模式下，如果使用未声明的变量，会抛出 `ReferenceError` 错误。
2. **禁止删除变量**：在严格模式下，无法使用 `delete` 操作符删除变量。
3. **禁止删除不可删除的属性**：在严格模式下，无法删除不可删除的属性。
4. **禁止函数参数重名**：在严格模式下，函数参数不能重名。
5. **禁止使用 `with` 语句**：在严格模式下，无法使用 `with` 语句。
6. **禁止 `this` 指向全局对象**：在严格模式下，函数内部的 `this` 不能指向全局对象。

---

1. **async、await的设计和实现**：

   **设计**：
   - `async`关键字用于声明一个异步函数，该函数会隐式地返回一个`Promise`对象。
   - `await`关键字用于在异步函数内部等待一个`Promise`对象的解决（resolve）或拒绝（reject）。
   - 当`await`一个`Promise`时，函数执行会暂停在该点，直到`Promise`解决，然后继续执行后续的代码。
   - 如果`Promise`被拒绝，`await`会抛出异常，可以通过`try...catch`语句捕获。

   **实现**：
   - 在JavaScript引擎中，`async`函数会被编译成一个返回`Promise`的函数。
   - `await`关键字会被编译成`Promise`的`.then()`和`.catch()`方法的调用。
   - 当`await`一个值时，JavaScript引擎会创建一个微任务（microtask），该任务会在当前执行栈的同步代码执行完毕后立即执行。

   **原理**：
   - `async`函数内部的代码是按照同步的方式编写的，但实际上是异步执行的。
   - `await`关键字使得异步代码看起来像是同步的，因为它暂停了函数的执行，直到`Promise`解决。
   - 这种设计使得异步代码更加易于理解和维护。

   **例子**：

   ```javascript
   async function fetchData() {
       try {
           let response = await fetch('https://api.example.com/data');
           let data = await response.json();
           console.log(data);
       } catch (error) {
           console.error('Error fetching data:', error);
       }
   }

   fetchData();
   ```

   在这个例子中，`fetchData`函数是一个异步函数，它使用`await`关键字等待`fetch`函数返回的`Promise`解决，并获取响应数据。如果`fetch`或`response.json()`失败，错误会被`catch`块捕获并打印出来。

2. **深拷贝需要注意哪些问题**：
   - [循环引用]：需要检测并处理，以避免无限递归。
   - [特殊对象类型]：如函数、`Date`、`RegExp`等，需要特别处理。
   - [性能问题]：对于大型对象，深拷贝可能会很耗时。
   - [深拷贝的实现方法]：可以使用递归、结构化克隆算法或库（如Lodash的`cloneDeep`）来实现。
     - **JSON.parse(JSON.stringify(obj))**：
       - 这是最简单的方法，通过递归的方式深度遍历对象，将每个属性的值进行复制。
       - 但这种方法存在一些缺陷，例如无法处理undefined、Symbol、Function等特殊类型，也无法处理循环引用的问题。
     - **递归函数实现深拷贝**：
       - 通过递归地遍历对象的每个属性，如果是对象或数组，则继续递归拷贝，否则直接复制属性值。
       - 这种方法可以处理循环引用和特殊类型，但需要手动编写递归逻辑。
     - **使用第三方库（如Lodash的cloneDeep方法）**：
       - Lodash是一个一致性、模块化、高性能的JavaScript实用工具库，其中cloneDeep方法可以实现深拷贝。
       - 这种方法简单方便，但会增加项目的依赖。

3. **判断数组的方法**：
   - `Array.isArray(obj)`: 最直接的方法。
   - `obj instanceof Array`: 检查对象的原型链。
   - `Object.prototype.toString.call(obj) === '[object Array]'`: 更通用的方法，适用于跨iframe的情况。

4. **借鉴React diff算法实现树节点更新**：
   - [理解React的diff算法]：基于树的分层比较，通过key来优化。
   - [实现思路]：递归地比较新旧树，找到差异并更新。
   - [性能优化]：使用虚拟DOM减少真实DOM操作，利用key来快速定位节点。

5. **中间页携带cookie**：
   - 设置cookie时指定`domain`、`path`等属性，确保跨页面可访问。
   - 使用`Secure`和`HttpOnly`属性来增强安全性。

6. **跨域问题**：
   - 使用CORS（`Access-Control-Allow-Origin`等头信息）。
   - JSONP（只支持GET请求）。
   - WebSocket（适用于实时通信）。
   - 代理服务器（如Nginx）。

7. **webpack工作流程**：
   - [解析入口]：从入口文件开始构建依赖图。
   - [模块解析]：通过加载器处理不同类型的模块。
   - [代码分割]：将代码分割成多个包以优化加载性能。
   - [优化]：包括代码压缩、树摇（Tree Shaking）等。
   - [输出]：将打包后的代码输出到指定目录。

8. **webpack loader解决场景问题**：
   - 使用`babel-loader`转换ES6+代码。
   - 使用`css-loader`和`style-loader`处理CSS。
   - 使用`file-loader`和`url-loader`处理文件资源。
   - 自定义加载器以满足特定需求。

9. **ES5实现继承和原型链理解**：
    - 使用`prototype`属性实现原型链继承。
    - 通过`Object.create`或构造函数内部的`this`来创建实例。
    - 理解原型链的查找机制：当访问一个对象的属性时，如果该对象没有该属性，则会沿着其原型链向上查找。

10. **require和import的区别**：
    - `require`是CommonJS的导入语法，用于Node.js，同步加载模块。
    - `import`是ES6 Modules的导入语法，用于浏览器和Node.js（支持ES6 Modules），支持静态分析和代码分割，异步加载模块。

---

### 递归深拷贝会有什么问题吗？

递归深拷贝虽然是一种有效的复制对象的方法，但它也面临一些潜在的问题和挑战：

1. **循环引用**：
   - 如果对象中存在循环引用（即一个对象通过其属性间接或直接引用自身），递归深拷贝可能会陷入无限循环。
   - 为了解决这个问题，通常需要使用一种机制来检测和处理循环引用，比如使用`WeakMap`或`Map`来跟踪已经访问过的对象。

2. **性能问题**：
   - 对于大型或深度嵌套的对象，递归深拷贝可能会非常耗时，因为它需要遍历对象的每一个属性。
   - 此外，如果对象中包含大量不可变数据（如原始值或已冻结的对象），则无需深拷贝这些数据，但递归算法可能仍然会遍历它们，从而造成不必要的性能开销。

3. **特殊对象类型**：
   - 某些特殊对象类型（如函数、`undefined`、`Symbol`、`BigInt`等）在递归深拷贝时可能无法正确处理。
   - 例如，函数通常不能被拷贝，因为它们包含执行上下文和闭包等复杂的状态。
   - 此外，`undefined`和`Symbol`值在JSON序列化时也会丢失。

4. **内置对象和原型链**：
   - 递归深拷贝通常 **只复制** 对象的 **可枚举属性**，并且可能无法正确复制 -> 对象的 -> 原型链和内置对象的特性（如`Date`、`RegExp`、`Map`、`Set`等）。
   - 这些对象需要 **特殊的处理逻辑** 来确保它们被正确地拷贝。
     - 特殊的处理逻辑可能包括：创建新的对象并复制原型链、调用内置对象的构造函数等。

5. **内存消耗**：
   - 由于递归深拷贝需要创建一个完全独立的新对象，因此它会消耗更多的内存。
   - 对于大型对象或需要频繁进行深拷贝的应用来说，这可能会成为一个问题。

6. **安全性问题**：
   - 如果递归深拷贝函数没有正确处理恶意输入（如包含恶意代码的对象），则可能会引发安全问题。
   - 例如，拷贝过程中可能会执行不安全的代码或暴露敏感信息。

---
