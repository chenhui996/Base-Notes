# 从输入URL到页面渲染的完整流程

## 1. 输入 URL 并解析

- 当用户在浏览器地址栏输入 URL 并按下回车后，浏览器随即对 URL 进行解析。
- URL 通常由多个部分组成，包括：
  - **协议**：如 `http` 或 `https`，决定了通信的方式。
  - **主机名**：可以是 **域名** 或 **IP地址**。
  - **端口号**：默认为 80(HTTP) 或 443(HTTPS)。
  - **路径**：指定服务器上的资源位置（/）。
  - **查询参数**：以？开头，包含键值对参数。
  - **片段标识**：以#开头，用于页面内定位。
- 浏览器会根据不同的 URL 类型进行 **特殊处理**：
  - **IP地址**：浏览器会直接尝试与该 IP 建立连接。
  - **域名**：浏览器会启动 **DNS 解析流程** 来 **获取对应的 IP 地址**。
  - **非HTTP(S)的特殊协议（如 mailto:、file: 等）**:
    - 浏览器会 **直接执行** 对应的操作，比如 **打开邮件客户端** 或 **本地文件**。

## 2. DNS域名解析（这个过程大约需要 20~120ms（甚至更长））

- **适合面试的表达**：
  - DNS解析就是：浏览器把 **域名** 换成 **IP** 的过程。
  - 先查缓存。没有，再问DNS服务器。
  - 前端可以用 dns-prefetch 提前 **解析域名** 优化性能。

### 详细版

- 当浏览器遇到域名（如www.example.com），需要先通过 DNS 查询获取对应的 IP 地址，流程如下：

#### (1)缓存查询
  
- 浏览器会按照顺序检查缓存:
  - **浏览器缓存** -> **系统缓存（Hosts 文件）** -> **路由器缓存** -> **运营商 DNS 缓存**。
- 如果都没命中，才会去走 **DNS 查询**。

#### (2)DNS 查询流程

1. 递归查询：浏览器向 **本地 DNS 服务器（如8.8.8.8）** 发起请求。
2. 迭代查询：本地 DNS 服务器依次查询：
   1. 根域名服务器（.）
   2. 顶级域名服务器（.com）
   3. 权威 DNS 服务器（example.com）

> 最终返回 `www.example.com` 的 IP。

#### (3)前端相关的 DNS 优化

- **DNS Prefetching**：提前解析可能访问的域名。
- **HTTP/2 Server Push**：服务器可推送 DNS 记录，减少查询。
- **DoH（DNS over HTTPS）**：加密 DNS，防劫持（如 1.1.1.1）。

---

## 3. 建立 TCP 连接（三次握手）

- 在 DNS 解析获取到 IP 地址后，浏览器会通过 **TCP 三次握手** 与 **服务器** 建立 **可靠连接**。
- 这是 HTTP 请求的基础，确保双方都能 **正常收发数据**。

- **适合面试的表达**：

1. 客户端发 `SYN`
2. 服务器返回 `SYN + ACK`
3. 客户端再回复 `ACK`

### 三次握手流程（详细版）

#### 1. 客户端 -> 服务端

- 客户端 发送 `SYN=1`（同步）包。
  - 并随机生产一个 **初始序列号** `seq=x`，表示：“**我想建立连接，我的初始序号是x**”。

#### 2. 服务端 -> 客户端

- 服务端 回复 `SYN=1, ACK=1`，确认号`ack=x+1`。
  - 并生成自己的序列号`seq=y`，表示：“**收到你的请求了（x+1），我也要建立连接，我的序号是y**”

#### 3. 客户端 -> 服务端

- 客户端 发送 `ACK=1`，确认号 `ack=y+1`。
  - 表示：“**收到你的确认了（y+1），连接建立成功！**”

### 追问：为什么需要三次握手？

- **防止 历史 重复连接 初始化导致的资源浪费**
  - 注：如果是两次握手，服务器可能 **误处理** 旧的重复 SYN 请求。
  - 解释：
    - 客户端通过序列号（seq）匹配服务端的回复，只对最新的握手发送第三次ACK。
    - 服务端虽然会响应所有SYN，但只有被客户端确认的连接能建立成功，旧请求会因缺少ACK超时释放。
    - 这样既 **保证了时序**，又 **避免了资源浪费**。
- **同步双方的初始序列号**
  - 注：保证数据顺序。
- **确认双方的收发能力正常**

---

## 4. 发送 HTTP 请求

- **适合面试的表达**：
  - TCP 连接建立后，浏览器会发送 HTTP 请求，包括：
    - 请求行（如`GET /index.html HTTP/1.1`）
    - 请求头（如缓存控制、Cookie、压缩格式等）
    - 请求体-可选（POST时携带数据）
  - 前端可以通过合理设置：
    - 缓存头
    - 启动压缩
    - keep-alive
  - 来优化请求效率。

### 详细版（发送 HTTP 请求）

- 在 TCP/TLS 连接建立后，客户端（如浏览器）会发送 **HTTP 请求** 到服务器，请求资源（如HTML、CSS、JS等）。
- HTTP 请求由以下组成：
  - **请求行**
  - **请求头**
  - **请求体（可选）**
- 接下来挨个介绍

#### 1. 请求行（Request Line）

- 定义 **请求方法**、**目标资源**和 **HTTP 版本**：

```http
GET /index.html HTTP/1.1
```

- **方法**：
  - `GET`：获取资源（无请求体）。
  - `POST`：提交数据（有请求体，如表单）。
  - `PUT/DELETE`：RESTful API 常用。
  - `HEAD`：仅获取响应头（用于检查缓存）。
- **路径**：
  - `/index.html`：请求的资源路径。
- **协议版本**：
  - `HTTP/1.1`：（主流，支持持久连接）。
  - `HTTP/2`：（二进制分帧，多路复用）。
  - `HTTP/3`：（基于QUIC，0-RTT 优化）。

#### 2. 请求头（Request Headers）

- **缓存控制**：
  - 决定是否使用缓存（强缓存/协商缓存）

```http
Cache-Control: no-cache
If-Modified-Since: Wed, 21 Oct 2022 07:28:00 GMT
```

- **身份认证**：
  - 携带 登录态（Cookie）或 Token（Authorization）

```http
Cookie: sessionId=abc123
Authorization: Bearer xxxxxx
```

- **性能优化**：
  - `Accept-Encoding`：告诉服务器支持的压缩格式（减少传输体积）
  - `Connection: keep-alive`：保持 TCP 连接复用（HTTP/1.1默认）

```http
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
```

### 3. 请求体（Request Body）

- **GET 请求**：通常没有请求体（参数放在 URL 的 `?` 后）
- **POST/PUT 请求**：
  - 常见格式：
    - `JSON`
    - `FormData`
    - `x-www-form-urlencoded`

```http
Content-Type: application/json

{"username": "test", "password": "123456"}
```

### 前端需要关注的重点

1. **缓存策略**：避免 **静态资源** 重复请求（Cache-Control: max-age=3600）
2. **减少请求体积**: 开启 `gzip` 压缩（服务端配置）
3. **连接复用**：HTTP/1.1 默认 `keep-alive`，减少 TCP 握手开销。
4. **安全知识**：敏感信息避免放在 URL 中（GET请求）

- 一句话总结：
  - **缓存** -> 让浏览器少发请求
  - **压缩** -> 让请求传的数据更小
  - **连接复用** -> 让请求发得更快

---

## 5. 服务器处理请求

- **面试精简回答**：
  - 服务器处理主要分三步：
    - 先通过 **负载均衡** 分流 ->
    - 然后 **后端处理（SSR 渲染或 API 查询）** ->
    - 最后 **包装响应**：设置缓存、安全等 HTTP 头。
  - 前端需要特别关注 **SSR 的实现** 和 **缓存策略** 的设置。

### 详细版（服务器处理请求）

- 当 HTTP 请求到达服务器后，会经历以下几个关键处理阶段：

#### 1. 流量调度阶段

- **负载均衡（如 Nginx）**
  - 把请求合理分配到不同的服务器。
- **反向代理**
  - 先检查是否有 -> 缓存好的 -> 静态资源（JS/CSS/图片）
  - 如果有就直接返回，不再麻烦后端

#### 2. 业务处理阶段

- **动态页面（SSR）**
  - 服务器实时生成包含具体信息的HTML。
- **API 数据处理**
  - 先查缓存（Redis），没有再查数据库（MySQL）

#### 3. 响应包装阶段

- **缓存控制**
  - `Cache-Control: max-age=3600`：告诉浏览器可以缓存 1 小时。
  - `ETag: "abc123"`：类似文件指纹，用来判断内容是否变化。
- **安全加固**
  - `CSP`: 限制哪些外部资源可以加载（防XSS攻击）
  - `HSTS`：强制使用 HTTPS（防中间人攻击）
- **CDN优化**
  - `CDN-Cache-Control`：专门控制 CDN 节点的缓存行为。
  - 举例：让全球各地的 CDN 节点缓存不用的时长。

### 前端需要了解的重点

1. **SSR 和 CSR 的区别**：知道何时该用 服务端渲染 （SEO 优化场景）
2. **缓存策略**：理解 Cache-Control 和 ETag 的工作原理。
3. **安全常识**：明白为什么需要 CSP 和 HSTS 这些头。

---

> 下来，只记录面试精简回答

## 6. 浏览器接受响应

- 浏览器 **收到响应后先看状态码**：
  - 200 直接处理。
  - 304 用缓存。
  - 301/302 跳转新地址。
- 然后 **解压 gzip 压缩的内容**
- 最后 **检查缓存策略** 决定 **是否要发新请求**

## 7. 解析 HTML

- HTML 解析是：
  - 边下载 边转 DOM 树的过程。
  - 遇到 `<script>` 会阻塞解析（除非加 async/defer）。
  - CSS 不会阻塞解析 但会 阻塞渲染。
- 浏览器会用 **预加载扫描器** 提前发现资源。

## 8. 解析 CSS

- CSS 解析生成 CSSOM 树，选择器从右向左匹配。
- 要注意，CSS会阻塞渲染：
  - 必须等 CSSOM 创建完，浏览器才会显示内容。
  - 这是为了避免页面闪动（FOUC）。

## 9. 构建渲染树

- 渲染树 = DOM + CSSOM，去掉隐藏元素。
- 然后计算布局（重排）。
  - 这里要避免频繁读取 offsetWidth 等属性，会导致性能问题。
  - 动画推荐用 transform。

## 10. 绘制与合成

- 浏览器分层绘制：
  - transform 等属性，会创建独立合成层由 GPU 加速。
  - 滚动和动画，交给合成线程处理，不会阻塞主线程。

## 11. 加载子资源

- 图片/字体异步加载，要注意：
  - 设好 **宽高** 避免布局抖动。
  - JS 用 defer 保持执行顺序
  - async 适合不依赖 dom 的脚本。
  - 懒加载推荐用 Intersection Observer。

## 12. 执行 Javascript

- JS 通过时间循环机制执行，注意：
  - 宏任务和微任务的区别。
  - 小心闭包和事件监听导致的内存泄漏。

## 13. 交互阶段

- 优化交互要用：事件委托减少监听器。
- 高频事件加防抖节流。
- Service Worker 可以缓存资源实现离线可用。
