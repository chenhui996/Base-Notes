# React 语料

## 1. React 基础概念

---

### 1.1 JSX

- 问：
  - **(1)什么是 JSX？**
  - **(2)有什么优势？**
- 答：
  - **定义**：jsx 是一种 js 的语法扩展，用于 **描述 UI 结构**，它将 **xml/html 语法 与 js 融合**。
  - **优势**：
    - **(1)可读性高**：代码直观地表达 UI 结构。
    - **(2)调试方便**：编译后，可以捕获 语法错误。
    - **(3)工具支持丰富**：很多 ide 都对 jsx 有良好的 **语法高亮** 和 **代码补全** 支持。

---

### 1.2 虚拟 dom 与 Reconciliation

- 问：
  - **React 如何通过 虚拟dom 实现 高效更新？**
- 答：
  - **虚拟dom**：
    - React 使用 内存中的 轻量级 js 对象来 **模拟真实 dom**。
    - 通过 **比较前后两次** 虚拟 dom 的差异，找到 **最小的更新范围**。
  - **diff 算法**：
    - 利用 diff 算法（调和算法 Reconciliation）快速找到 **变更部分**。
    - 再将 **更新** 应用到 **真实 dom 上**，**降低重绘开销**。

---

### 1.3 单向数据流

- 问：**解释一下 react 的 单向数据流 概念**
- 答：
  - **原理**：
    - 数据从 **父组件** 通过 **props** 向 **子组件** 传递。
    - **子组件** 无法直接修改 **父组件** 的数据。
    - 保证了 **数据流** 的 **可控性** 和 **调试的简单性**。
  - **好处**：
    - 有助于 **维护组件状态 的稳定** 和降低 **追踪数据变化** 时的难易度。

---

## 2. 组件 与 状态管理

---

### 2.1 函数组件 vs 类组件

- 问：**函数组件 与 类组件 有什么区别？**
- 答：
  - **函数组件**：更加简洁，借助 **hooks** 能够实现 **状态** 和 **副作用** 管理，适用于 **大部份场景**。
  - **类组件**：
    - 传统写法，拥有 **生命周期** 方法，代码结构 **较为分散**（不同 **生命周期方法** 中的逻辑 **分散在多个函数中**）
    - 但有时 在某些场景下（比如 **错误边界**）依然需要使用。

---

### 2.2 状态管理

- 问：**React 中如何 管理组件内部状态 和 跨组件共享状态？**
- 答：
  - **组件内部状态**：
    - 函数组件：使用 `useState`、`useReducer` 进行状态管理。
    - 类组件：使用 `this.state` 和 `this.setState`。
  - **跨组件共享状态**：
    - 通过 Context API 传递 **全局状态**，**避免多层级传递 props**。
    - 借助 第三方状态管理库，如 **redux**、**mobx** 或 **recoil**。

---

## 3. 生命周期 与 hooks 对应关系

---

### 3.1 生命周期方法（类组件）

- 问：**列举说明 react 类组件 的 主要生命周期方法**
- 答：
  - **Mounting 挂载阶段**：
    - `constructor`：初始化状态 和 绑定事件。
    - `componentDidMount`：组件挂载后 执行，一般用于 **数据获取**、**订阅** 等。
  - **Updating 更新阶段**：
    - `shouldComponentUpdate`：控制是否重新渲染。
    - `componentDidUpdate`：组件更新后执行，用于响应 props 或 state 变化。
  - **Unmouning 卸载阶段**：
    - `componentWillUnmount`：组件卸载前执行，主要用于 **清除操作**，如 **取消订阅**、**清除定时器**等。

---

### 3.2 hooks 替代方案

- 问：**hooks 如何替代 类组件 中的 生命周期方法？**
- 答：
  - **useEffect**：
    - 通过 **依赖数组** 的不同场景，可以实现：
      - `componentDidMount`：传入空数组(`[]`)。
      - `componentDidUpdate`：传入需要监听的具体变量(`[a, b]`)
      - `componentWillUnmount`：返回 清理函数(`() => { return {}}`)。
    - **useLayoutEffect**：
      - 与 `useEffect` 类似，但会在所有 dom 变更后，同步执行。
      - 适合需要 **立即读写 dom** 的场景。

---

## 4. React 高级概念

---

### 4.1 Context API

- 问：**如何使用 Context API 实现全局状态共享？**
- 答：
  - **基本用法**：
    - (1)创建 Context：`const MyContext = React.createContext(initValue);`
    - (2)提供数据：使用 `<MyContext.Provider value = {...}>{组件}</MyContext.Provider>` 包裹需要共享全局状态的组件。
    - (3)消费数据：在 **子组件** 中使用 `useContext(MyContext)` 或 Context Consumer 组件 **获取数据**。

---

### 4.2 Refs 与 dom 操作

- 问：**React 中如何使用 refs？有什么常见场景？**
- 答：
  - **定义**：refs 用于 直接访问 **dom 元素** 或 **组件实例**。
  - **使用方法**：
    - 函数 hooks：使用 `useRef` 在 函数组件 中创建 refs。
    - 类组件：使用 `React.createRef` 在 类组件 中创建 refs。
  - **场景**：直接操作 dom 的场景：
    - 处理焦点
    - 文本选择
    - 媒体播放控制
    - 集成第三方库

---

### 4.3 Error Boundaries（错误边界）

- 问：**React 中如何处理 组件树 中的错误？**
- 答：
  - **措施**：使用 Error Boundaries 错误边界捕获错误。
  - **定义**：Error Boundary 是一种 react 组件，用于 捕获 其子组件树 中的 js 错误，并显示降级 UI，也就是 fallback 兜底UI。
  - **使用方式**：
    - 必须使用 **类组件**。
    - 必须实现 `componentDidCatch`、`static getDerivedStateFromError` 方法。
    - 目前 **函数组件** 还不支持直接作为 Error Boundary。

### 4.4 Portals

- 问：**什么是 React Portals？适用场景有哪些？**
- 答：
  - **定义**：Portals 允许将 组件 渲染到 dom 节点树 中的其他位置，而 **不局限于 父组件 的 dom 层级**。
  - **场景**：弹窗、模态框、工具提示等，需要 脱离 父组件 **样式限制** 的场景。

---
