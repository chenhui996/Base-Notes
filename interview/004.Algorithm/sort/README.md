# 排序

## 冒泡排序

### 1. 常规写法（无特殊写法 优化）

- 一组数据进行：两两比较，两两交换，只要满足交换需求，即：
  - `const temp = arr[j]`
  - `arr[i] = arr[j]`
  - `arr[j] = temp`
- 第一轮执行完：第一个满足的目标值，将被排到最右侧，也就是第一轮冒泡结束。
  - `n-1 次比较`
- 第二轮执行：继续 **从头进行** 两两比较，两两交换，直到 -> 结尾 - 1。这个 1，是上一轮已经完成排序的值。
  - `n-2 次比较`
- 之后同理，只是 **每轮进行的遍历 的 次数**，均递减1。
  - 总比较次数：`(n-1) + (n-2) + (n-3) + ... + 1`

### 2. 第二种写法（优化：记录 当前轮次 是否 发生过 排序操作）

- 第二种写法是在第一种写法的基础上改良而来的。
- 这种写法相对于第一种写法的优点是：
  - 如果一轮比较中没有发生过交换，则立即停止排序，因为此时剩余数字一定已经有序了。
    - `let isSorted;`
    - `if(!isSorted) break`

### 3. 第三种写法（优化：在第二种写法的基础上，且 记录当前轮次最后一次更新的 索引）

- 第三种写法是在第二种写法的基础上改良而来的。
- 这种写法的优化是：
  - 每次只比对至 `lastIndex`，缩小比较次数。因为 `lastIndex` 之后的元素，没有发生比较，必然已满足条件（如有序。
