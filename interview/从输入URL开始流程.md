# 从输入URL开始建立前端知识体系

这篇文章全面介绍了: 从输入 URL 开始 -> 前端页面渲染完成 -> 整个知识体系。包括：

- **浏览器主要进程**
- **输入网址解析**
- **缓存机制**
- **DNS 域名解析**
- **TCP/IP 连接**
- **HTTP 请求及各版本特点**
- **服务器处理请求**
- **浏览器渲染页面**
- **断开连接等内容**
  
并对其中的 **关键概念** 和 **流程** 进行了详细阐述。

---

## 前置内容 浏览器主要进程

浏览器是多进程的，主要分为：

- **浏览器主进程**：只有一个，主要控制页面的 **创建**、**销毁**、**网络资源管理**、**下载** 等。
- **第三方插件进程**：每一种类型的插件对应一个进程，仅当使用该插件时才创建。
- **GPU进程**：最多一个，用于3D绘制等。
- **浏览器渲染进程(浏览器内核)**：每个Tab页对应一个进程，互不影响。
  - GUI渲染线程：负责渲染浏览器界面，解析HTML、CSS，构建DOM树和Render树，布局和绘制等。
  - JavaScript引擎线程：负责处理JavaScript脚本程序。
  - 事件触发线程：负责事件轮询，发送事件到事件队列中。
  - 定时触发器线程：setInterval与setTimeout所在的线程。
  - 异步http请求线程：处理XMLHttpRequest请求。

## 第一部分 输入网址并解析

这里，我们只考虑输入的是一个 URL 结构字符串，如果是非 URL 结构的字符串，则会用 **浏览器默认的搜索引擎** 搜索该字符串。

### URL的组成

- URL 主要由 协议、主机、端口、路径、查询参数、锚点 **6** 部分组成！
  - **协议**：http、https、ftp、file 等。
  - **主机**：www.baidu.com、www.google.com 等。
  - **端口**：80、8080、443 等。
  - **路径**：/、/index.html、/images 等。
  - **查询参数**：?id=1&name=2 等。
  - **锚点**：#top、#bottom 等。

## 1. 解析 URL

输入URL后，浏览器会解析出 **协议、主机、端口、路径等** 信息，并构造一个HTTP请求。

### 缓存检查流程

- **强缓存阶段（浏览器本地判断，不发送请求）**
  - 浏览器检查请求资源的 `Cache-control`(优先级高) 和 `Expires` 字段：
    - **若未过期（命中强缓存）**：直接读取本地缓存，不会发送任何请求。
    - **若已过期（未命中强缓存）**：进入下一步，**发送请求**。
- **协商缓存阶段（需发送请求，由服务器判断）**
  - **浏览器发送请求**，并自动附加以下请求头（来自上一次服务器响应的值）：
    - `If-None-Match`（对应上一次响应的 `Etag`）
    - `If-Modified-Since`（对应上一次响应的 `Last-modified`）
  - **服务端收到请求后，检查资源是否变化**：
    - **未变化（命中）**：返回 304 Not Modified（空响应体，浏览器复用本地缓存）。
    - **若资源已修改（未命中协商缓存）**：返回 200 OK 和 新资源数据。

### HSTS

- HSTS，HTTP Strict Transport Security，简单说就是强制客户端使用 HTTPS 访问页面。其原理就是：
  1. 在服务器响应头中添加 Strict-Transport-Security，可以设置 max-age。
  2. 用户访问时，服务器种下这个头。
  3. 下次如果使用 http 访问，只要 max-age 未过期，客户端会进行内部跳转，可以看到 307 Redirect Internel 的响应码。
  4. 变成 https 访问源服务器。
- 由于安全隐患，会 **使用 HSTS 强制客户端使用 HTTPS 访问页面**。
- 当你的网站均采用 HTTPS，并符合它的安全规范：
  - 就可以申请加入 HSTS 列表，之后用户不加 HTTPS 协议再去访问你的网站，浏览器都会定向到 HTTPS。
- 无论匹配到没有，都要开始 DNS 查询工作了。

### 浏览器缓存

#### 强缓存与协商缓存

1. **强缓存阶段**：

- 浏览器在首次请求资源时，服务器会在响应头中包含Expires和Cache-Control字段，用于指定资源的缓存有效期。
- 在缓存有效期内，浏览器会直接从本地缓存中加载资源，而不会向服务器发送请求。
- 当Expires和Cache-Control设置的缓存时间过期后，强缓存就会结束。

2. **协商缓存阶段**：

- 一旦强缓存过期，浏览器会向服务器发送一个请求，以验证本地缓存的资源是否仍然有效。
- 在请求头中，浏览器会包含一些条件标签，如If-Modified-Since（对应服务器上资源的最后修改时间）或If-None-Match（对应资源的唯一标识，如ETag）。
- 服务器会根据这些条件标签来判断资源是否有更新。如果资源未发生变化，服务器会返回304 Not Modified状态码，
  - 并附带一些新的响应头（如更新后的Last-Modified或ETag），但不会返回资源内容本身。
- 浏览器在收到304状态码后，会继续使用本地缓存的资源。

#### 协商缓存的头部字段

- **Last-Modified / If-Modified-Since**：

  - Last-Modified：服务器在响应头中发送，表示资源的最后修改时间。
  - If-Modified-Since：浏览器在请求头中发送，其值为上次响应头中的Last-Modified值。
  - 服务器会比较这两个时间戳，如果资源未修改，则返回304状态码。

- **ETag / If-None-Match**：

  - ETag：服务器在响应头中发送，表示资源的唯一标识。
  - If-None-Match：浏览器在请求头中发送，其值为上次响应头中的ETag值。
  - 服务器会比较这两个ETag值，如果资源未修改，则返回304状态态码。

#### 总结

- 当Expires和Cache-Control设置的缓存过期后，强缓存就会结束，此时浏览器会开始走协商缓存流程。
- 通过向服务器发送请求并携带条件标签，浏览器可以验证本地缓存的资源是否仍然有效。如果资源未发生变化，服务器会返回304状态码，浏览器则继续使用本地缓存的资源。
- 这一过程有助于减少网络请求次数和带宽使用，提高网页加载速度。

### 存储位置（缓存）

#### Service Worker

- 运行在**浏览器背后的独立线程**，一般用于 **实现缓存** 功能。
- 使用 Service Worker的话，传输协议必须为 HTTPS。
  - 因为 Service Worker 中涉及到 **请求拦截**，所以必须使用 HTTPS 协议来 **保障安全**。
- Service Worker 的 **缓存** 与 -> 浏览器其他 **内建的** 缓存机制不同:
  - 它可以让我们 -> 自由控制: **缓存哪些文件**、**如何匹配缓存**、**如何读取缓存**，并且 **缓存是持续性的**。

- **Service Worker 缓存功能的三个步骤**：

1. **注册与安装Service Worker**：
   - 首先，需要在网页中注册Service Worker。这通常是在页面的JavaScript代码中通过调用`navigator.serviceWorker.register()`方法来实现的。
   - 注册成功后，Service Worker会触发`install`事件。在这个事件的处理函数中，我们可以编写缓存需要的文件的逻辑。
     - 这通常包括使用`caches.open()`打开一个缓存对象，然后使用`cache.addAll()`方法将一系列资源添加到缓存中。
2. **拦截与处理请求**：
   - 当用户下次访问页面时，Service Worker会拦截页面的网络请求。这是通过监听`fetch`事件来实现的。
   - 在`fetch`事件的处理函数中，我们可以编写逻辑来 -> 检查 -> 请求的资源 -> 是否已经 **缓存** 在Service Worker中。
     - 如果存在，就使用`caches.match()`方法从缓存中读取资源，并通过`Response`对象返回给页面。
   - 如果缓存中没有找到请求的资源，那么就会继续执行正常的网络请求流程去获取资源。
3. **处理未命中缓存的请求**：
   - 当Service Worker没有命中缓存时，它会调用`fetch`函数去网络上获取数据。
   - 获取到的数据可以根据需要被添加到缓存中，以便下次请求时可以直接从缓存中读取。
   - 无论数据是从缓存中读取的还是通过网络请求获取的，浏览器都会通过Service Worker将内容返回给页面，使得页面看起来像是从Service Worker中获取的内容。

> 这三个步骤共同构成了Service Worker实现缓存功能的核心流程。
> 通过注册与安装Service Worker、拦截与处理请求以及处理未命中缓存的请求，我们可以有效地利用Service Worker来提升网页的加载速度和用户体验。
