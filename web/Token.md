# Token

- Session 是将要验证的信息存储在服务端;
  - 并以 SessionId 和'数据'进行对应;
- SessionId 由客户端存储;
  - 在请求时将 SessionId 也带过去;
  - 因此实现了状态的对应;
- 而 Token 是在服务端:
  - 将用户信息经过 Base64Url 编码过后传给在客户端;
  - 每次用户请求的时候都会带上这一段信息;
  - 因此服务端拿到此信息进行解密后:
    - 就知道此用户是谁了;
    - 这个方法叫做 JWT(Json Web Token);
- Token 相比较于 Session 的优点在于:
  - 当后端系统有多台时;
  - 由于是客户端访问时直接带着数据;
  - 因此无需做共享数据的操作;

## Token 的优点

- 简洁:
  - 可以通过 URL,POST 参数或者是在 HTTP 头参数发送;
  - 因为数据量小，传输速度也很快;
- 自包含:
  - 由于串包含了用户所需要的信息;
  - 避免了多次查询数据库;
- 因为 Token 是以 Json 的形式保存在客户端的:
  - 所以 JWT 是跨语言的;
- 不需要在服务端保存会话信息:
  - 特别适用于分布式微服务;

## JWT 的结构

- 实际的 JWT 结构:
  - 是一个很长的字符串;
  - 中间用.分割成三个部分;

### Header

- 是一个 Json 对象:
  - 描述 JWT 的元数据;
  - 通常是下面这样子的:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

- 上面代码中:
  - alg 属性表示签名的算法（algorithm）;
    - 默认是 HMAC SHA256（写成 HS256）;
  - typ 属性表示这个令牌（token）的类型（type）;
    - JWT 令牌统一写为 JWT;
- 最后:
  - 将上面的 JSON 对象使用 Base64URL 算法转成字符串;

---

- JWT 作为一个令牌（token）;
  - 有些场合可能会放到 URL:
    - 比如 api.example.com/?token=xxx;
  - Base64 有三个字符+、/和=;
    - 在 URL 里面有特殊含义;
    - 所以要被替换掉:
      - =被省略;
      - +替换成-;
      - /替换成`_`;
    - 这就是 Base64URL 算法;

### Payload

- Payload 部分也是一个 Json 对象:
  - 用来存放实际需要传输的数据;
  - JWT 官方规定了下面几个官方的字段供选用:
    - iss (issuer)：签发人
    - exp (expiration time)：过期时间
    - sub (subject)：主题
    - aud (audience)：受众
    - nbf (Not Before)：生效时间
    - iat (Issued At)：签发时间
    - jti (JWT ID)：编号
  - 当然除了官方提供的这几个字段:
    - 我们也能够自己定义私有字段;
    - 下面就是一个例子

```json
{
  "name": "Cain",
  "age": 18
}
```

- 默认情况下 JWT 是不加密的;
  - 任何人只要在网上进行 Base64 解码就可以读到信息;
- 所以一般不要将秘密信息放在这个部分;
  - 这个 Json 对象也要用 Base64URL 算法转成字符串;

### Signature

- Signature 部分是对前面的两部分的数据:

  - 进行签名，防止数据篡改;

- 首先需要定义一个秘钥:
  - 这个秘钥只有服务器才知道;
  - 不能泄露给用户;
- 然后使用 Header 中指定的签名算法(默认情况是 HMAC SHA256):
  - 算出签名以后将 Header、Payload、Signature 三部分拼成一个字符串:
    - 每个部分用.分割开来，就可以返给用户了;

---

- HS256 可以使用单个密钥:
  - 为给定的数据样本创建签名;
- 当消息与签名一起传输时:
  - 接收方可以使用'相同的密钥'来验证签名是否与消息匹配;


## 总结

- 相信大家看到:
    - Cookie
    - Session
    - Token
- 有一定的了解了:
    - 接下来再回顾一下重要的知识点

---

- Cookie是存储在客户端的;
- Session是存储在服务端的:
    - 可以理解为一个'状态列表';
    - 拥有一个'唯一会话标识'SessionId;
    - 可以根据SessionId在'服务端查询'到存储的信息;
- Session会引发一个问题:
    - 即后端多台机器时Session共享的问题:
        - 解决方案可以使用Spring提供的框架(存疑);
- Token类似一个令牌:
    - 无状态的;
    - 服务端所需的信息:
        - 被Base64编码后放到Token中;
    - 服务器可以直接解码出其中的数据;
