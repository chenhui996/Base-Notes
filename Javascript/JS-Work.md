# JavaScript 是如何运行的？

## 什么是 JavaScript？

- 我们来确认一下 JavaScript 的定义:
  - JavaScript 是一门'解释型'的'动态语言';

### 解释型语言

- '解释型语言'是相对于:
  - '编译型语言'存在的;
- '源代码'不是'直接编译为目标代码';
  - 而是转成'中间代码';
    - 再由'解释器'对'中间代码'进行'解释运行';

---

- 主流编程语言有:
  - 编译型（如 C++）
  - 解释型（如 JavaScript）
  - 半解释半编译（如 Java）

## 代码是怎么运行的？

- 首先我们来了解一下代码是怎么运行的;

---

- 我们知道，代码是由 CPU 执行的;
- 而目前的 CPU 并'不能直接执行':
  - 诸如 if…else 之类的语句;
- 它只能执行'二进制指令';
  - 但是'二进制指令'对'人类'实在是'太不友好'了;
    - 我们很难快速准确的判断:
      - 一个二进制指令:
        - 1000010010101001 代表什么？
        - 所以科学家们发明'汇编语言';

### 汇编语言

- '汇编语言'实际上就是'二进制指令'的'助记符';

---

- 假设:
  - 读取内存操作是: 10101010;
  - 内存地址是: 10101111;
  - 寄存器地址是: 11111010;
- 那么完整的操作 101010101010111111111010:
  - 就代表'读取'某个'内存地址'的'值':
    - 并'装载'到'寄存器';
- 而'汇编语言'并没有改变这种操作方式;
  - 它只是'二进制指令'的'映射':

```
LD：10101010
id:10101111
R:11111010
```

- 这样上述指令就可以表达为:
  - LD
  - id
  - R
- 大大增强了代码的可读性。

---

- 但是这样还不够友好:
  - CPU 只能执行三地址表达式;
    - 和人的思考方式、语言模式相距甚远;
- 所以我们又发明了'高级语言';

### 高级语言

```
代码是写给人看的，不是写给机器看的，只是顺便计算机可以执行而已;
```

- 高级语言之所以称之为“高级”:
  - 就是因为它:
    - '更加符合'我们的'思维'和'阅读习惯';
- if…else 这种语句:
  - '看起来'要比 1010101010 舒服的多了;
- 但是'计算机'并'不能直接执行高级语言';
  - 所以还需要把'高级语言转化为':
    - '汇编语言/机器指令'才能执行;
- 这个过程就是编译;

## JavaScript 需要编译吗？

- JavaScript 毫无疑问是'高级语言':
  - 所以它肯定是'需要编译后'才能'执行';
- 但为什么我们又称之为'解释型语言'呢？
  - 它和'编译型语言'、'半解释半编译型'语言又有什么区别呢？
  - 我们先从'编译'说起;

### 编译

- 之前我们已经了解'编译'的概念，下面我们来聊聊平台:
  - 同样一份 C++代码:
    - 在 Windows 上会编译成.obj 文件;
    - 而在 Linux 上则生成.o 文件;
  - 两者不能通用:
    - 这是因为一个'可执行文件':
      - 除了代码外:
        - 还需要'操作系统 API、内存、线程、进程'等'系统资源';
  - 而不同的'操作系统'其'实现也不尽相同':
    - 比如我们熟悉的:
      - I/O 多路复用（事件驱动的灵魂）;
        - 在 Windows 上的实现方案是 IOCP 方案;
        - 在 Linux 上是 epoll;
- 所以针对不同的平台:
  - '编译型语言'需要'分别编译';
    - 甚至需要'分别编写';
  - 而且'生成的可执行文件'其'格式'并'不相同';

### 跨平台

- Java 在此之上更进一步:
  - 它通过引入'字节码'实现了'跨平台运行':
    - 无论是在什么操作系统上.java 文件:
      - 编译出的都是.class 文件;
        - 这就是'字节码文件'，一种'中间形态'的'目标代码';
    - 然后 Java 对'不同的系统提供':
      - 不同的 Java 虚拟机:
        - 用于'解释执行'字节码文件;
    - '解释执行'并'不'生成'目标代码':
      - 但其最终还是要转为:
        - '汇编/二进制指令'来给'计算机执行'的;

---

- 假如我们自己'完全独立'的'新写'一个简单的'操作系统':
  - 那么它能不能运行 Java 呢？
  - 很显然是不能的:
    - 因为并没有这个'系统相应的 JVM';
- 所以'Java 的跨平台'、任何'其他语言的跨平台'，都是有'局限性'的;

---

- Java 采用'半解释半编译'的好处就是:
  - 大大提升了开发效率;
- 然而相应的则降低了:
  - 代码的执行效率;
- 毕竟'虚拟机是有性能损失'的;

### 解释执行

- JavaScript 则更进一步;
  - 它是完全的'解释执行':
    - 或者叫做'即时编译';
      - 它不会有中间代码生成;
      - 也不会有目标代码生成;
      - 这个过程通常由:
        - 宿主环境（如浏览器、Node.js）包办;

## 编译过程

- 现在我们确认了:
  - 即使是解释执行的语言;
  - 也是需要编译的;
- 那么代码是如何编译的呢？
  - 我们来简单了解一下;

### 词法分析

- 词法分析会把:
  - 语句分解成'词法单元';
    - 即 Token;

```js
function square(n) {
  return n * n;
}
```

- 这个'函数'会被'词法分析器'识别为:
  - `function`
  - `square`
  - `(，n，)`
  - `{，return，，n ,*，n ，}`
- 并且给它们加上标注:
  - 代表这是'一个变量'还是'一个操作';

### 语法分析

- 这个过程会把 Token:
  - 转化成抽象语法树(AST):

```AST
{
  type:'function',
    id:{
      type:'id'
      name:'square'
    },
    params:[
      {
        type:'id',
        name:'n'
      }
    ]
    ...
}
```

### 优化及代码生成

- 在这一步编译器会做一些优化工作:
  - 比如:
    - 删除多余运算
    - 删除未用赋值
    - 合并部分变量
    - 等等
- 最后生成目标代码;

---

- 由于'即时编译型语言'的'编译':
  - 通常发生在运行前几微秒;
    - 所以'编译器'来不及做太多的'优化工作';
- 这也是相比'编译型语言':
  - 早期 JavaScript 性能孱弱的原因之一;
- 不过就现在而言:
  - 益于 V8 引擎:
    - 相比'早期的 JavaScript 的引擎'转换成'字节码'或'解释执行';
      - Node.js 可以用 V8 提供的 JS2C 工具将 JavaScript 转译为 C++代码;
  - JavaScript 和其他语言性能上的差距已经不足为道了;
