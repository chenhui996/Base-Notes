# JS 运行机制

- 本文大致分为以下这样的步骤:
  - 来帮助我们'由广入深'更加清晰的了解'JS 运行机制';

---

- 首先我们要了解:
  - '进程'的概念
  - '线程'的概念
- 其次我们要知道:
  - '浏览器'的'进程线程'常识;
- 再然后通过:
  - Event Loop
  - 宏任务(macrotask)
  - 微任务(microtask)
  - 来看浏览器的几个线程间:
    - 是怎样配合的;
- 再然后通过例子来印证我们的猜想;
- 最后提下 NodeJS 的运行机制;

## 面试必问

- JS 运行机制:
  - 在平常前端面试时不管是:
    - '笔试题'还是'面试题'命中率都极高;
- 说到 JS 运行机制，你知道多少;
- 看到这大家可能会说:
  - JS 运行机制嘛，很简单，事件循环、宏微任务那点东西;

---

- 是的，作为一名前端我们都了解;
- 但是如果这真的面试问到了这个地方;
  - 你真的可以答好吗(扪心自问);

### 场景模拟

- 不管你对 JS 了解多少，到这里大家不防先停止一下阅读;

---

- 假设你目前在面试:
  - 面试官让你阐述下'JS 运行机制';
  - 思考下你的答案，用 20 秒的时间(面试时 20s 已经很长了);
  - 然后带着答案再接着往下看:
- 引用的作者(isboyjc)名言：
  **没有思考的阅读纯粹是消磨时间罢了**

### 回过神来

- 也有很多刚开始接触 JS 的同学会被:
  - 任务队列
  - 执行栈
  - 微任务
  - 宏任务
- 这些高大上点的名次搞的很懵;

---

- 接下来，我们来细致的梳理一遍:
  - 你就可以清晰的了解它们了!(这是本文目标)

## 进程与线程

### 什么是进程

- 我们都知道:
  - CPU 是计算机的核心;
  - 承担所有的计算任务;

---

- 官网说法:
  - 进程是 CPU '资源分配'的:
    - 最小单位;
- 字面意思就是:
  - 进行中的程序,我将它理解为:
    - 一个可以独立运行:
      - 且拥有自己的资源空间的'任务程序';

---

- 进程包括:
  - 运行中的程序;
  - 程序所使用到的:
    - 内存
    - 系统资源

---

- CPU 可以有很多进程;
- 我们的电脑每打开一个软件:
  - 就会产生'一个'或'多个'进程;
- 为什么电脑运行的软件多就会卡:
  - 是因为'CPU'给每个'进程':
    - 分配资源空间;
  - 但是一个 CPU 一共就那么多资源;
    - 分出去越多，越卡;
- 每个进程之间是相互独立的;
  - CPU 在运行一个进程时:
    - 其他的进程处于'非运行'状态;

---

- CPU 使用:
  - 时间片轮转调度算法:
    - 来实现同时运行多个进程;

### 什么是线程

- 线程是 CPU'调度'的:
  - 最小单位
- 线程是建立在:
  - 进程的基础上的:
    - 一次程序运行单位;
- 通俗点解释:
  - 线程就是'程序'中的一个'执行流';
  - 一个'进程'可以有'多个线程';

---

- 一个进程中:
  - 只有一个'执行流'称作:
    - 单线程;
- 即程序执行时:
  - 所走的程序路径按照:
    - 连续顺序排下来;
      - 前面的必须处理好，后面的才会执行;

---

- 一个进程中:
  - 有'多个执行流'称作:
    - 多线程;
- 即在一个程序中:
  - 可以同时运行多个不同的线程;
    - 来执行不同的任务;
- 也就是说允许单个程序创建:
  - 多个'并行'执行的线程:
    - 来完成各自的任务;

### 进程和线程的区别

- 进程是'操作系统分配资源'的最小单位;
- 线程是'程序执行'的最小单位;

---

- 一个进程由'一个'或'多个'线程组成;
- 线程可以理解为是:
  - 一个进程中:
    - 代码的:
      - 不同执行路线;

---

- 进程之间相互独立;
- 但同一进程下的:
  - 各个线程间:
    - 共享程序的:
      - 内存空间(包括代码段、数据集、堆等);
      - 及一些'进程级'的资源(如打开文件和信号);

---

- 调度和切换:
  - 线程上下文切换:
    - 比进程上下文切换:
      - 要快得多;

### 多进程和多线程

- 多进程:
  - 多进程指的是在同一个时间里:
    - 同一个计算机系统中:
      - 允许'两个或两个以上'的'进程'处于'运行状态';

---

- 多进程带来的好处是明显的:
  - 比如大家可以在网易云听歌的同时:
    - 打开编辑器敲代码;
  - '编辑器'和'网易云'的'进程之间不会相互干扰';

---

- 多线程:
  - 多线程是指程序中:
    - 包含多个执行流;
  - 即在一个程序中,可以同时运行:
    - 多个'不同的线程'来执行'不同的任务';
  - 也就是说允许单个程序:
    - 创建多个'并行'执行的线程:
      - 来完成各自的任务;

## JS 为什么是单线程

- JS 的单线程，与它的用途有关;
- 作为浏览器脚本语言，JavaScript 的主要用途是:
  - 与用户互动;
  - 以及操作 DOM;
- 这决定了它只能是单线程;
  - 否则会带来很复杂的同步问题;
    - 比如:
      - 假定 JavaScript 同时有两个线程:
        - 一个线程在某个 DOM 节点上'添加内容';
        - 另一个线程删除了这个节点;
        - 这时浏览器应该以哪个线程为准？

---

- 还有人说 js'还有'Worker 线程;
  - 对的;
  - 为了利用多核 CPU 的计算能力;
    - HTML5 提出 Web Worker 标准:
      - 允许 JavaScript 脚本创建多个线程;
      - 但是'子线程'是完全受'主线程'控制的;
      - 而且不得操作 DOM;

<br>

- 所以，这个标准并没有改变:
  - JavaScript 是单线程的本质;

---

- 了解了'进程'和'线程'之后;
- 接下来看看浏览器解析:
  - 浏览器之间也是有些许差距的;
  - 不过大致是差不多的;
- 下文我们皆用:
  - 市场占有比例最大的 Chrome 为例;

## 浏览器

### 浏览器是多进程的

- 作为前端，免不了和浏览器打交道;
- 浏览器是多进程的;
  - 拿 Chrome 来说;
    - 我们每打开一个 Tab 页就会产生一个进程;
    - 我们使用 Chrome 打开'很多标签页不关';
      - 电脑会越来越卡;
      - 不说其他，首先就很耗 CPU(上文提到:每有一个新进程，cpu 就会分配给其独立资源);

### 浏览器包含哪些进程

- Browser 进程:
  - 浏览器的'主进程'(负责协调、主控):
    - 该进程只有一个;
  - 负责'浏览器'界面显示:
    - 与用户交互。如前进，后退等;
  - 负责各个'页面的管理':
    - 创建和销毁其他进程;
  - 将渲染(Renderer)进程得到的:
    - 内存中的 Bitmap(位图):
      - '绘制'到'用户界面'上;
  - '网络资源'的管理，下载等;

---

- 第三方插件进程:
  - 每种类型的插件对应一个进程:
    - 当使用该插件时才创建;

---

- GPU 进程:
  - 该进程也只有一个:
    - 用于 3D 绘制等等

---

- 渲染进程(重):
  - 即通常所说的'浏览器内核'(Renderer 进程，内部是多线程);
  - 每个 Tab 页面都有一个:
    - 渲染进程，互不影响;
  - 主要作用为:
    - 页面渲染
    - 脚本执行
    - 事件处理等

### 为什么浏览器要多进程

- 我们假设浏览器是单进程:
  - 那么某个 Tab 页崩溃了，就影响了整个浏览器;
  - 同理如果插件崩溃了也会影响整个浏览器;
- 当然多进程还有其它的诸多优势，不过多阐述;
- 浏览器'进程'有很多;
  - 每个'进程'又有'很多线程'，都会'占用内存';
- 这也意味着'内存等'资源消耗会很大:
  - 有点拿'空间'换'时间'的意思;
- 到此可不只是为了让我们理解为何 Chrome 运行时间长了电脑会卡;
  - 哈哈，第一个重点来了;

### 简述渲染进程 Renderer(重)

- 页面的渲染
- JS 的执行
- 事件的循环
- 都在渲染进程内执行:
  - 所以我们要重点了解渲染进程;

---

- 渲染进程是'多线程'的:
  - 我们来看'渲染进程'的一些'常用较为主要的线程';

### 渲染进程 Renderer 的主要线程

#### GUI 渲染线程

- 负责:
  - 渲染浏览器界面
  - 解析 HTML，CSS
  - 构建 DOM 树
  - RenderObject 树
  - 布局和绘制
  - 等
- 解析 html 代码(HTML 代码本质是字符串):
  - 转化为浏览器认识的节点;
  - 生成 DOM 树;
    - 也就是 DOM Tree;
- 解析 css，生成 CSSOM(CSS 规则树);
- 把 DOM Tree 和 CSSOM 结合;
  - 生成 Rendering Tree(渲染树);

---

- 当我们修改了一些元素的'颜色'或者'背景色':
  - 页面就会重绘(Repaint);

---

- 当我们修改元素的尺寸:
  - 页面就会回流(Reflow);

---

- 当页面需要 Repaing 和 Reflow 时:
  - GUI 线程执行，绘制页面;

---

- '回流(Reflow)'比'重绘(Repaint)'的'成本要高';
  - 我们要尽量避免 Reflow 和 Repaint;

---

- 'GUI 渲染线程'与'JS 引擎线程'是互斥的:
  - 当 JS 引擎执行时:
    - GUI 线程会被挂起(相当于被冻结了);
  - GUI 更新会被保存在一个队列中:
    - 等到 JS 引擎空闲时立即被执行;
