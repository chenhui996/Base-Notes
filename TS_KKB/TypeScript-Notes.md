# TypeScript

- 推荐用 vscode 进行编译:
  - 因为 vscode 是基于 typescript 进行编译的;
- 默认情况下，ts 文件的后缀是:
  - draft.ts

## 将 ts 文件转换成 js 文件

- 在命令行输入：

```
$tsc index.ts
```

- 然后，目录下即生成一个新的.js 结尾的文件;

### --outDir

- 指定编译文件输出目录:

```
$tsc --outDir ./dist ./ts_kkb/exp1.ts
```

- 执行后:
  - exp1.js 文件，将会在./dist 文件夹下生成;

### --target

- 指定编译的代码版本:
  - 默认为 ES3;
  - 所以要用--target 进行代码版本控制;

```
$tsc --outDir ./dist --target es5 ./ts_kkb/exp1/ts
```

- 这样，代码编译后，将是基于 es5 版本的 js 代码文件;

### --watch

- 在监听模式下运行:
  - 当文件发生改变时，自动进行编译:

```
$tsc --outDir ./dist --target es5 --watch ./ts_kkb/exp1/ts
```

- 自动：可以理解成类似 nodemon 的自动化;

## 编译配置文件

- 每次编译都调用那么长的命令，太繁琐，所以 tsc 支持我们进行————编译配置文件

### tsconfig.json

- 所有配置文件，都直接在此文件下进行配置， 然后编译成一个命令，统一执行;

```json
{
  "compilerOptions": {
    "outDir": "./dist",
    "target": "ES6",
    "watch": true
  },
  "include": ["./src/**/*"]
}
```

- include: 指定 ts 编译起效的目录;
- `**`: 所有目录(包括子目录);
- `*`: 所有文件，也可以指定类型文件;

- 配置完成后，只需要在命令行输入：
  - tsc，即可运行;

### --project

- 使用--project 或-p 指定配置文件目录;
  - 默认是加载该目录下的 tsconfig.json 文件;
- 若配置文件不叫 tsconfig.json:

```
tsc -p ./configs/ts.json
```

## 动态类型语言&静态类型语言

### 动态类型语言

- 程序'运行期间'才做数据类型检查的语言，如: JavaScript

### 静态类型语言

- 程序'编译期间'做数据类型检查的语言，如：Java

## 静态类型语言的优缺点

### 优点：

- 程序编译阶段(配合 IDE、编辑器甚至可以在编码阶段)：
  - 即可发现一些潜在错误;
  - 避免程序在'生产环境'运行了以后再出现错误;
- 编码规范、有利于团队开发协作、也更有利于大型项目开发、项目重构;
- 配合 IDE、编辑器提供更强大的代码智能提示/检查;
- 代码即文档;

### 缺点

- 麻烦;
- 缺少灵活性;

## 动态类型语言的优缺点

### 优点

- 静态类型语言的缺点;

### 缺点

- 静态类型语言的优点;

## 类型系统

- 类型系统包含两个重要的组成部分：
  - 类型标注(定义、注解) - typing;
  - 类型检测(检查) - type-checking;

### 类型标注

- 在代码中给'数据'添加类型说明:
  - 变量
  - 函数(参数、返回值)
- 当一个变量或函数(参数)等被标注以后：
  - 就'不能存储'或'传入'与'标注类型不符合'的'类型';
- 有了标注，TypeScript 编译器就能按照标注对这些数据进行类型合法检测;
- 有了标注，各种编辑器、IDE 等就能进行智能提示;

### 类型检测

- 对'类型'数据进行检测;
  - 注意，检查的是类型，不是值;
  - 值是业务层具体逻辑;

## 类型标注

- 在 ts 中，基本语法格式:
  - 数据载体: 类型;
- ts 的类型标注:
  - 基础的简单的类型标注;
  - 高级的深入的类型标注;

### null和undefind

- 是所有类型的子类型：
  - 所有类型的值，都可以设置为null和undefind,不会报错;
- 所有未标注的对象的类型，都为any;

### strictNullChecks

- 严格的空值检查字段;
- 写在tsconfig.json的配置项;
  - strictNullChecks:true

