# JavaScript 中的垃圾回收

- 根据 Wiki 的定义，垃圾回收是一种'自动'的'内存管理机制';
- 当计算机上的'动态内存'不再需要时:
  - 就应该予以释放，以让出内存;
- 直白点讲，就是程序是运行在内存里的;
  - 当声明一个变量、定义一个函数时都会占用内存;
  - 内存的容量是有限的;
    - 如果变量、函数等只有产生没有消亡的过程:
    - 那迟早内存有被'完全占用'的时候;
    - 这个时候，不仅自己的程序无法正常运行,，连其他程序也会受到影响;
- 好比生物只有出生没有死亡，地球总有被撑爆的一天;
  - 所以，在计算机中，我们需要垃圾回收;
- 需要注意的是:
  - 定义中的“自动”的意思是:
    - 语言可以帮助我们回收内存垃圾;
    - 但并不代表我们不用关心内存管理;
    - 如果操作失当，JavaScript 中依旧会出现内存溢出的情况;

## 垃圾回收基于两个原理：

- 考虑某个变量或对象:
  - 在未来的程序运行中将'不会被访问';
- 向这些对象要求归还内存;

- 而这两个原理中，最主要的也是最艰难的部分就是:
  - 找到“所分配的内存确实已经不再需要了”。

## 垃圾回收方法

- 下面我们看看在 JavaScript 中:
  - 是如何找到不再使用的内存的;
- 主要有两种方式：
  - 引用计数;
  - 标记清除;

### 引用计数（reference counting）

- 在内存管理环境中:
  - 对象 A 如果有访问对象 B 的权限;
  - 叫做对象 A 引用对象 B;
- 引用计数的策略是:
  - 将“对象是否不再需要”简化成:
    - “对象有没有其他对象引用到它”;
  - 如果没有对象引用这个对象，那么这个对象将会被回收
  - 例：

```js
let obj1 = { a: 1 }; // 一个对象（称之为 tar）被创建，赋值给 obj1，tar 的引用个数为 1
let obj2 = obj1; // tar 的引用个数变为 2

obj1 = 0; // tar 的引用个数变为 1
obj2 = 0; // tar 的引用个数变为 0，此时对象 A 就可以被垃圾回收了
```

- 但是引用计数有个最大的问题： 循环引用。

```js
function func() {
  let obj1 = {};
  let obj2 = {};

  obj1.a = obj2; // obj1 引用 obj2
  obj2.a = obj1; // obj2 引用 obj1
}
```

- 当函数 func 执行结束后，返回值为 undefined;
  - 所以整个函数以及内部的变量都应该被回收;
- 但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0;
  - 所以他们不会被回收;

* 要解决循环引用的问题;
  - 最好是在不使用它们的时候:手工将它们设为空;
  - 上面的例子可以这么做：

```js
function func() {
  let obj1 = {};
  let obj2 = {};

  obj1.a = obj2; // obj1 引用 obj2
  obj2.a = obj1; // obj2 引用 obj1

  //清空引用
  obj1 = null;
  obj2 = null;
}
```

### 标记-清除（mark and sweep）

- 这是 JavaScript 中'最常见'的垃圾回收方式;
- 为什么说这是种最常见的方法:

  - 因为从 2012 年起，'所有现代浏览器'都使用了'标记-清除'的垃圾回收方法;
  - 除了低版本 IE...它们采用的是引用计数方法;

- 那什么叫标记清除呢？
